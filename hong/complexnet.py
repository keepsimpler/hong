# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_complexnet.ipynb (unless otherwise specified).

__all__ = ['xception_block', 'complex_net', 'complexnet_1', 'complex_stage', 'complexnet_2']

# Cell
from .imports import *
from .graph import *

# Cell
def xception_block(inputs, filters, kernel_size, strides):
    if len(inputs) >= 2:
        x = layers.add(inputs)
    else:
        x = inputs[0]
    x = layers.ReLU()(x)
    x = layers.SeparableConv2D(filters=filters, kernel_size=kernel_size, strides=strides,
                               padding='same', use_bias=False,
                               depthwise_initializer='he_normal',pointwise_initializer='he_normal')(x)
    x = layers.BatchNormalization()(x) #gamma_initializer=keras.initializers.zeros(), moving_variance_initializer='zeros'
    return x

# Cell
def complex_net(G, input, filters, kernel_size, stages_nums:tuple):
    n = G.graph['n'] # number of nodes
    assert n == sum(stages_nums) # assert sum of nodes per stage equal to total number of nodes
    layers_nums = []
    for i in range(len(stages_nums)):
        for j in range(sum(stages_nums[:i]), sum(stages_nums[:(i+1)])):
            layers_nums.append(i)
    layers_nums.append(layers_nums[-1]) # add layer id of the final output node
#     print(layers_nums)

    results = {}
    for _id in sorted(G.nodes()): # sorted nodes
        if _id == -1: # if the unique input node
            results[-1] = input
            continue
        for pred in G.predecessors(_id): #
            succs = [pred] #
            for succ in G.successors(pred):
                if succ == _id:
                    break
                succs += [succ]
            real_pred = succs[-1]
            layer_diff = layers_nums[_id] - layers_nums[real_pred]
#             print(_id, pred, real_pred, layer_diff)
            if layer_diff > 0:
                results[pred] = layers.MaxPool2D(pool_size=2**layer_diff)(results[pred])
        inputs = [results[pred] for pred in G.predecessors(_id)]  # get inputs
        if  _id == n:  # if the unique output node, just add them all
             results[_id] = layers.add(inputs)
        else:  # if inner nodes, add them all, then xception op.
            results[_id] = xception_block(inputs, filters=filters, kernel_size=kernel_size, strides=1)
    model = keras.Model(inputs = input, outputs = results[n])
    return model

# Cell
def complexnet_1(n, c, stages_nums:tuple, input, filters, kernel_size, num_classes):
    x = layers.SeparableConv2D(filters=filters//2, kernel_size=kernel_size, padding='same', name='stem_conv')(input)
    stem_output = layers.BatchNormalization()(x)
    stage1_input = keras.Input(shape=stem_output.shape[1:])
    G = cascade(n, c=c)
    G = after_DAG(G)
    stage1 = complex_net(G, stage1_input, filters=filters, kernel_size=kernel_size, stages_nums=stages_nums)
    stage1_output = stage1(stem_output)

    top = stage1_output
    #top = xception_block(inputs=[stage1_output], filters=1280, kernel_size=kernel_size, strides=1)
    top = layers.GlobalMaxPool2D()(top)
    top = layers.Dense(num_classes, activation='softmax')(top)

    model = keras.Model(inputs=input, outputs=top)
    return model

# Cell
def complex_stage(G, input, filters, kernel_size, strides):
    n = G.graph['n'] # number of nodes
    results = {}
    for _id in sorted(G.nodes()): # sorted nodes
        if _id == -1: # if the unique input node
            if strides == 2: # if need downsampling
                results[-1] = layers.MaxPool2D()(input)
            else:
                results[-1] = input
            continue
        inputs = [results[pred] for pred in G.predecessors(_id)]  # get inputs
        if  _id == n:  # if the unique output node, just add them all
             results[_id] = layers.add(inputs)
        else:  # if inner nodes, add them all, then xception op.
            results[_id] = xception_block(inputs, filters=filters, kernel_size=kernel_size, strides=1)
    model = keras.Model(inputs = input, outputs = results[n])
    return model

# Cell
def complexnet_2(n, c, input, filters, kernel_size, num_classes):
    x = layers.SeparableConv2D(filters=filters//2, kernel_size=kernel_size, padding='same', name='stem_conv')(input)
    stem_output = layers.BatchNormalization()(x)
    stage1_input = keras.Input(shape=stem_output.shape[1:])
    G = cascade(nodes, c=c)
    G = after_DAG(G)
    stage1 = complex_stage(G, stage1_input, filters=filters, kernel_size=kernel_size, strides=2)
    stage1_output = stage1(stem_output)

    stage2_input = keras.Input(shape=stage1_output.shape[1:])
    G = cascade(nodes, c=c)
    G = after_DAG(G)
    stage2 = complex_stage(G, stage2_input, filters=filters*2, kernel_size=kernel_size, strides=2)
    stage2_output = stage2(stage1_output)

    stage3_input = keras.Input(shape=stage2_output.shape[1:])
    G = cascade(nodes, c=c)
    G = after_DAG(G)
    stage3 = complex_stage(G, stage3_input, filters=filters*4, kernel_size=kernel_size, strides=2)
    stage3_output = stage3(stage2_output)

    #top = xception_block(inputs=[stage3_output], filters=1280, kernel_size=3, strides=1)
    top = stage3_output
    top = layers.GlobalMaxPool2D()(top)
    top = layers.Dense(num_classes)(top)
    model = keras.Model(inputs=input, outputs=top)
    return model